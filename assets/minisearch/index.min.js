!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?module.exports=i():"function"==typeof define&&define.amd?define(i):(t="undefined"!=typeof globalThis?globalThis:t||self).MiniSearch=i()}(this,(function(){"use strict";const t="KEYS",i="VALUES",e="";class s{constructor(t,i){const e=t.t,s=Array.from(e.keys());this.set=t,this.i=i,this.o=s.length>0?[{node:e,keys:s}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(0===this.o.length)return{done:!0,value:void 0};const{node:t,keys:i}=n(this.o);if(n(i)===e)return{done:!1,value:this.result()};const s=t.get(n(i));return this.o.push({node:s,keys:Array.from(s.keys())}),this.dive()}backtrack(){if(0===this.o.length)return;const t=n(this.o).keys;t.pop(),t.length>0||(this.o.pop(),this.backtrack())}key(){return this.set.h+this.o.map((({keys:t})=>n(t))).filter((t=>t!==e)).join("")}value(){return n(this.o).node.get(e)}result(){switch(this.i){case i:return this.value();case t:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const n=t=>t[t.length-1],o=(t,i,s,n,r,h,c,u)=>{const a=h*c;t:for(const f of t.keys())if(f===e){const i=r[a-1];i<=s&&n.set(u,[t.get(f),i])}else{let e=h;for(let t=0;t<f.length;++t,++e){const n=f[t],o=c*e,h=o-c;let u=r[o];const a=Math.max(0,e-s-1),l=Math.min(c-1,e+s);for(let t=a;t<l;++t){const e=n!==i[t],s=r[h+t]+ +e,c=r[h+t+1]+1,a=r[o+t]+1,f=r[o+t+1]=Math.min(s,c,a);f<u&&(u=f)}if(u>s)continue t}o(t.get(f),i,s,n,r,e,c,u+f)}};class r{constructor(t=new Map,i=""){this.u=void 0,this.t=t,this.h=i}atPrefix(t){if(!t.startsWith(this.h))throw new Error("Mismatched prefix");const[i,s]=h(this.t,t.slice(this.h.length));if(void 0===i){const[i,n]=d(s);for(const s of i.keys())if(s!==e&&s.startsWith(n)){const e=new Map;return e.set(s.slice(n.length),i.get(s)),new r(e,t)}}return new r(i,t)}clear(){this.u=void 0,this.t.clear()}delete(t){return this.u=void 0,a(this.t,t)}entries(){return new s(this,"ENTRIES")}forEach(t){for(const[i,e]of this)t(i,e,this)}fuzzyGet(t,i){return((t,i,e)=>{const s=new Map;if(void 0===i)return s;const n=i.length+1,r=n+e,h=new Uint8Array(r*n).fill(e+1);for(let t=0;t<n;++t)h[t]=t;for(let t=1;t<r;++t)h[t*n]=t;return o(t,i,e,s,h,1,n,""),s})(this.t,t,i)}get(t){const i=c(this.t,t);return void 0!==i?i.get(e):void 0}has(t){const i=c(this.t,t);return void 0!==i&&i.has(e)}keys(){return new s(this,t)}set(t,i){if("string"!=typeof t)throw new Error("key must be a string");this.u=void 0;return u(this.t,t).set(e,i),this}get size(){if(this.u)return this.u;this.u=0;const t=this.entries();for(;!t.next().done;)this.u+=1;return this.u}update(t,i){if("string"!=typeof t)throw new Error("key must be a string");this.u=void 0;const s=u(this.t,t);return s.set(e,i(s.get(e))),this}fetch(t,i){if("string"!=typeof t)throw new Error("key must be a string");this.u=void 0;const s=u(this.t,t);let n=s.get(e);return void 0===n&&s.set(e,n=i()),n}values(){return new s(this,i)}[Symbol.iterator](){return this.entries()}static from(t){const i=new r;for(const[e,s]of t)i.set(e,s);return i}static fromObject(t){return r.from(Object.entries(t))}}const h=(t,i,s=[])=>{if(0===i.length||null==t)return[t,s];for(const n of t.keys())if(n!==e&&i.startsWith(n))return s.push([t,n]),h(t.get(n),i.slice(n.length),s);return s.push([t,i]),h(void 0,"",s)},c=(t,i)=>{if(0===i.length||null==t)return t;for(const s of t.keys())if(s!==e&&i.startsWith(s))return c(t.get(s),i.slice(s.length))},u=(t,i)=>{const s=i.length;t:for(let n=0;t&&n<s;){for(const o of t.keys())if(o!==e&&i[n]===o[0]){const e=Math.min(s-n,o.length);let r=1;for(;r<e&&i[n+r]===o[r];)++r;const h=t.get(o);if(r===o.length)t=h;else{const e=new Map;e.set(o.slice(r),h),t.set(i.slice(n,n+r),e),t.delete(o),t=e}n+=r;continue t}const o=new Map;return t.set(i.slice(n),o),o}return t},a=(t,i)=>{const[s,n]=h(t,i);if(void 0!==s)if(s.delete(e),0===s.size)f(n);else if(1===s.size){const[t,i]=s.entries().next().value;l(n,t,i)}},f=t=>{if(0===t.length)return;const[i,s]=d(t);if(i.delete(s),0===i.size)f(t.slice(0,-1));else if(1===i.size){const[s,n]=i.entries().next().value;s!==e&&l(t.slice(0,-1),s,n)}},l=(t,i,e)=>{if(0===t.length)return;const[s,n]=d(t);s.set(n+i,e),s.delete(n)},d=t=>t[t.length-1],m="or",w="and",p="and_not";class v{constructor(t){if(null==(null==t?void 0:t.fields))throw new Error('MiniSearch: option "fields" must be provided');const i=null==t.autoVacuum||!0===t.autoVacuum?k:t.autoVacuum;this.l={...S,...t,autoVacuum:i,searchOptions:{...z,...t.searchOptions||{}},autoSuggestOptions:{...x,...t.autoSuggestOptions||{}}},this.m=new r,this.p=0,this.v=new Map,this.M=new Map,this.S={},this.O=new Map,this.F=[],this.I=0,this.j=new Map,this.D=0,this.T=null,this.A=null,this.C=F,this.addFields(this.l.fields)}add(t){const{extractField:i,tokenize:e,processTerm:s,fields:n,idField:o}=this.l,r=i(t,o);if(null==r)throw new Error(`MiniSearch: document does not have ID field "${o}"`);if(this.M.has(r))throw new Error(`MiniSearch: duplicate ID ${r}`);const h=this.addDocumentId(r);this.saveStoredFields(h,t);for(const o of n){const n=i(t,o);if(null==n)continue;const r=e(n.toString(),o),c=this.S[o],u=new Set(r).size;this.addFieldLength(h,c,this.p-1,u);for(const t of r){const i=s(t,o);if(Array.isArray(i))for(const t of i)this.addTerm(c,h,t);else i&&this.addTerm(c,h,i)}}}addAll(t){for(const i of t)this.add(i)}addAllAsync(t,i={}){const{chunkSize:e=10}=i,s={chunk:[],promise:Promise.resolve()},{chunk:n,promise:o}=t.reduce((({chunk:t,promise:i},s,n)=>(t.push(s),(n+1)%e==0?{chunk:[],promise:i.then((()=>new Promise((t=>setTimeout(t,0))))).then((()=>this.addAll(t)))}:{chunk:t,promise:i})),s);return o.then((()=>this.addAll(n)))}remove(t){const{tokenize:i,processTerm:e,extractField:s,fields:n,idField:o}=this.l,r=s(t,o);if(null==r)throw new Error(`MiniSearch: document does not have ID field "${o}"`);const h=this.M.get(r);if(null==h)throw new Error(`MiniSearch: cannot remove document with ID ${r}: it is not in the index`);for(const o of n){const n=s(t,o);if(null==n)continue;const r=i(n.toString(),o),c=this.S[o],u=new Set(r).size;this.removeFieldLength(h,c,this.p,u);for(const t of r){const i=e(t,o);if(Array.isArray(i))for(const t of i)this.removeTerm(c,h,t);else i&&this.removeTerm(c,h,i)}}this.j.delete(h),this.v.delete(h),this.M.delete(r),this.O.delete(h),this.p-=1}removeAll(t){if(t)for(const i of t)this.remove(i);else{if(arguments.length>0)throw new Error("Expected documents to be present. Omit the argument to remove all documents.");this.m=new r,this.p=0,this.v=new Map,this.M=new Map,this.O=new Map,this.F=[],this.j=new Map,this.I=0}}discard(t){const i=this.M.get(t);if(null==i)throw new Error(`MiniSearch: cannot discard document with ID ${t}: it is not in the index`);this.M.delete(t),this.v.delete(i),this.j.delete(i),(this.O.get(i)||[]).forEach(((t,e)=>{this.removeFieldLength(i,e,this.p,t)})),this.O.delete(i),this.p-=1,this.D+=1,this.maybeAutoVacuum()}maybeAutoVacuum(){if(!1===this.l.autoVacuum)return;const{minDirtFactor:t,minDirtCount:i,batchSize:e,batchWait:s}=this.l.autoVacuum;this.conditionalVacuum({batchSize:e,batchWait:s},{minDirtCount:i,minDirtFactor:t})}discardAll(t){const i=this.l.autoVacuum;try{this.l.autoVacuum=!1;for(const i of t)this.discard(i)}finally{this.l.autoVacuum=i}this.maybeAutoVacuum()}replace(t){const{idField:i,extractField:e}=this.l,s=e(t,i);this.discard(s),this.add(t)}vacuum(t={}){return this.conditionalVacuum(t)}conditionalVacuum(t,i){return this.T?(this.C=this.C&&i,null!=this.A||(this.A=this.T.then((()=>{const i=this.C;return this.C=F,this.performVacuuming(t,i)}))),this.A):!1===this.vacuumConditionsMet(i)?Promise.resolve():(this.T=this.performVacuuming(t),this.T)}async performVacuuming(t,i){const e=this.D;if(this.vacuumConditionsMet(i)){const i=t.batchSize||O.batchSize,s=t.batchWait||O.batchWait;let n=1;for(const[t,e]of this.m){for(const[t,i]of e)for(const[s]of i)this.v.has(s)||(i.size<=1?e.delete(t):i.delete(s));0===this.m.get(t).size&&this.m.delete(t),n%i==0&&await new Promise((t=>setTimeout(t,s))),n+=1}this.D-=e}await null,this.T=this.A,this.A=null}vacuumConditionsMet(t){if(null==t)return!0;let{minDirtCount:i,minDirtFactor:e}=t;return i=i||k.minDirtCount,e=e||k.minDirtFactor,this.dirtCount>=i&&this.dirtFactor>=e}get isVacuuming(){return null!=this.T}get dirtCount(){return this.D}get dirtFactor(){return this.D/(1+this.p+this.D)}has(t){return this.M.has(t)}getStoredFields(t){const i=this.M.get(t);if(null!=i)return this.j.get(i)}search(t,i={}){const{searchOptions:e}=this.l,s={...e,...i},n=this.executeQuery(t,i),o=[];for(const[t,{score:i,terms:e,match:r}]of n){const n=e.length||1,h={id:this.v.get(t),score:i*n,terms:Object.keys(r),queryTerms:e,match:r};Object.assign(h,this.j.get(t)),(null==s.filter||s.filter(h))&&o.push(h)}return t===v.wildcard&&null==s.boostDocument||o.sort(j),o}autoSuggest(t,i={}){i={...this.l.autoSuggestOptions,...i};const e=new Map;for(const{score:s,terms:n}of this.search(t,i)){const t=n.join(" "),i=e.get(t);null!=i?(i.score+=s,i.count+=1):e.set(t,{score:s,terms:n,count:1})}const s=[];for(const[t,{score:i,terms:n,count:o}]of e)s.push({suggestion:t,terms:n,score:i/o});return s.sort(j),s}get documentCount(){return this.p}get termCount(){return this.m.size}static loadJSON(t,i){if(null==i)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJS(JSON.parse(t),i)}static async loadJSONAsync(t,i){if(null==i)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJSAsync(JSON.parse(t),i)}static getDefault(t){if(S.hasOwnProperty(t))return b(S,t);throw new Error(`MiniSearch: unknown option "${t}"`)}static loadJS(t,i){const{index:e,documentIds:s,fieldLength:n,storedFields:o,serializationVersion:r}=t,h=this.instantiateMiniSearch(t,i);h.v=T(s),h.O=T(n),h.j=T(o);for(const[t,i]of h.v)h.M.set(i,t);for(const[t,i]of e){const e=new Map;for(const t of Object.keys(i)){let s=i[t];1===r&&(s=s.ds),e.set(parseInt(t,10),T(s))}h.m.set(t,e)}return h}static async loadJSAsync(t,i){const{index:e,documentIds:s,fieldLength:n,storedFields:o,serializationVersion:r}=t,h=this.instantiateMiniSearch(t,i);h.v=await A(s),h.O=await A(n),h.j=await A(o);for(const[t,i]of h.v)h.M.set(i,t);let c=0;for(const[t,i]of e){const e=new Map;for(const t of Object.keys(i)){let s=i[t];1===r&&(s=s.ds),e.set(parseInt(t,10),await A(s))}++c%1e3==0&&await C(0),h.m.set(t,e)}return h}static instantiateMiniSearch(t,i){const{documentCount:e,nextId:s,fieldIds:n,averageFieldLength:o,dirtCount:h,serializationVersion:c}=t;if(1!==c&&2!==c)throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version");const u=new v(i);return u.p=e,u.I=s,u.M=new Map,u.S=n,u.F=o,u.D=h||0,u.m=new r,u}executeQuery(t,i={}){if(t===v.wildcard)return this.executeWildcardQuery(i);if("string"!=typeof t){const e={...i,...t,queries:void 0},s=t.queries.map((t=>this.executeQuery(t,e)));return this.combineResults(s,e.combineWith)}const{tokenize:e,processTerm:s,searchOptions:n}=this.l,o={tokenize:e,processTerm:s,...n,...i},{tokenize:r,processTerm:h}=o,c=r(t).flatMap((t=>h(t))).filter((t=>!!t)).map(M(o)).map((t=>this.executeQuerySpec(t,o)));return this.combineResults(c,o.combineWith)}executeQuerySpec(t,i){const e={...this.l.searchOptions,...i},s=(e.fields||this.l.fields).reduce(((t,i)=>({...t,[i]:b(e.boost,i)||1})),{}),{boostDocument:n,weights:o,maxFuzzy:r,bm25:h}=e,{fuzzy:c,prefix:u}={...z.weights,...o},a=this.m.get(t.term),f=this.termResults(t.term,t.term,1,t.termBoost,a,s,n,h);let l,d;if(t.prefix&&(l=this.m.atPrefix(t.term)),t.fuzzy){const i=!0===t.fuzzy?.2:t.fuzzy,e=i<1?Math.min(r,Math.round(t.term.length*i)):i;e&&(d=this.m.fuzzyGet(t.term,e))}if(l)for(const[i,e]of l){const o=i.length-t.term.length;if(!o)continue;null==d||d.delete(i);const r=u*i.length/(i.length+.3*o);this.termResults(t.term,i,r,t.termBoost,e,s,n,h,f)}if(d)for(const i of d.keys()){const[e,o]=d.get(i);if(!o)continue;const r=c*i.length/(i.length+o);this.termResults(t.term,i,r,t.termBoost,e,s,n,h,f)}return f}executeWildcardQuery(t){const i=new Map,e={...this.l.searchOptions,...t};for(const[t,s]of this.v){const n=e.boostDocument?e.boostDocument(s,"",this.j.get(t)):1;i.set(t,{score:n,terms:[],match:{}})}return i}combineResults(t,i=m){if(0===t.length)return new Map;const e=i.toLowerCase(),s=y[e];if(!s)throw new Error(`Invalid combination operator: ${i}`);return t.reduce(s)||new Map}toJSON(){const t=[];for(const[i,e]of this.m){const s={};for(const[t,i]of e)s[t]=Object.fromEntries(i);t.push([i,s])}return{documentCount:this.p,nextId:this.I,documentIds:Object.fromEntries(this.v),fieldIds:this.S,fieldLength:Object.fromEntries(this.O),averageFieldLength:this.F,storedFields:Object.fromEntries(this.j),dirtCount:this.D,index:t,serializationVersion:2}}termResults(t,i,e,s,n,o,r,h,c=new Map){if(null==n)return c;for(const u of Object.keys(o)){const a=o[u],f=this.S[u],l=n.get(f);if(null==l)continue;let d=l.size;const m=this.F[f];for(const n of l.keys()){if(!this.v.has(n)){this.removeTerm(f,n,i),d-=1;continue}const o=r?r(this.v.get(n),i,this.j.get(n)):1;if(!o)continue;const w=l.get(n),p=this.O.get(n)[f],v=e*s*a*o*g(w,d,this.p,p,m,h),y=c.get(n);if(y){y.score+=v,E(y.terms,t);const e=b(y.match,i);e?e.push(u):y.match[i]=[u]}else c.set(n,{score:v,terms:[t],match:{[i]:[u]}})}}return c}addTerm(t,i,e){const s=this.m.fetch(e,D);let n=s.get(t);if(null==n)n=new Map,n.set(i,1),s.set(t,n);else{const t=n.get(i);n.set(i,(t||0)+1)}}removeTerm(t,i,e){if(!this.m.has(e))return void this.warnDocumentChanged(i,t,e);const s=this.m.fetch(e,D),n=s.get(t);null==n||null==n.get(i)?this.warnDocumentChanged(i,t,e):n.get(i)<=1?n.size<=1?s.delete(t):n.delete(i):n.set(i,n.get(i)-1),0===this.m.get(e).size&&this.m.delete(e)}warnDocumentChanged(t,i,e){for(const s of Object.keys(this.S))if(this.S[s]===i)return void this.l.logger("warn",`MiniSearch: document with ID ${this.v.get(t)} has changed before removal: term "${e}" was not present in field "${s}". Removing a document after it has changed can corrupt the index!`,"version_conflict")}addDocumentId(t){const i=this.I;return this.M.set(t,i),this.v.set(i,t),this.p+=1,this.I+=1,i}addFields(t){for(let i=0;i<t.length;i++)this.S[t[i]]=i}addFieldLength(t,i,e,s){let n=this.O.get(t);null==n&&this.O.set(t,n=[]),n[i]=s;const o=(this.F[i]||0)*e+s;this.F[i]=o/(e+1)}removeFieldLength(t,i,e,s){if(1===e)return void(this.F[i]=0);const n=this.F[i]*e-s;this.F[i]=n/(e-1)}saveStoredFields(t,i){const{storeFields:e,extractField:s}=this.l;if(null==e||0===e.length)return;let n=this.j.get(t);null==n&&this.j.set(t,n={});for(const t of e){const e=s(i,t);void 0!==e&&(n[t]=e)}}}v.wildcard=Symbol("*");const b=(t,i)=>Object.prototype.hasOwnProperty.call(t,i)?t[i]:void 0,y={[m]:(t,i)=>{for(const e of i.keys()){const s=t.get(e);if(null==s)t.set(e,i.get(e));else{const{score:t,terms:n,match:o}=i.get(e);s.score=s.score+t,s.match=Object.assign(s.match,o),I(s.terms,n)}}return t},[w]:(t,i)=>{const e=new Map;for(const s of i.keys()){const n=t.get(s);if(null==n)continue;const{score:o,terms:r,match:h}=i.get(s);I(n.terms,r),e.set(s,{score:n.score+o,terms:n.terms,match:Object.assign(n.match,h)})}return e},[p]:(t,i)=>{for(const e of i.keys())t.delete(e);return t}},g=(t,i,e,s,n,o)=>{const{k:r,b:h,d:c}=o;return Math.log(1+(e-i+.5)/(i+.5))*(c+t*(r+1)/(t+r*(1-h+h*s/n)))},M=t=>(i,e,s)=>({term:i,fuzzy:"function"==typeof t.fuzzy?t.fuzzy(i,e,s):t.fuzzy||!1,prefix:"function"==typeof t.prefix?t.prefix(i,e,s):!0===t.prefix,termBoost:"function"==typeof t.boostTerm?t.boostTerm(i,e,s):1}),S={idField:"id",extractField:(t,i)=>t[i],tokenize:t=>t.split(V),processTerm:t=>t.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(t,i)=>{"function"==typeof(null===console||void 0===console?void 0:console[t])&&console[t](i)},autoVacuum:!0},z={combineWith:m,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:{k:1.2,b:.7,d:.5}},x={combineWith:"and",prefix:(t,i,e)=>i===e.length-1},O={batchSize:1e3,batchWait:10},F={minDirtFactor:.1,minDirtCount:20},k={...O,...F},E=(t,i)=>{t.includes(i)||t.push(i)},I=(t,i)=>{for(const e of i)t.includes(e)||t.push(e)},j=({score:t},{score:i})=>i-t,D=()=>new Map,T=t=>{const i=new Map;for(const e of Object.keys(t))i.set(parseInt(e,10),t[e]);return i},A=async t=>{const i=new Map;let e=0;for(const s of Object.keys(t))i.set(parseInt(s,10),t[s]),++e%1e3==0&&await C(0);return i},C=t=>new Promise((i=>setTimeout(i,t))),V=/[\n\r\p{Z}\p{P}]+/u;return v}));
//# sourceMappingURL=index.min.js.map
